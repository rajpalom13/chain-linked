'use client';

/**
 * Canvas Editor Component
 * Main orchestrating component for the Canva-style carousel editor
 */

import { useRef, useEffect, useCallback, useState } from 'react';
import dynamic from 'next/dynamic';
import type Konva from 'konva';
import { toast } from 'sonner';
import { useCanvasEditor } from '@/hooks/use-canvas-editor';
import { useCarouselTemplates } from '@/hooks/use-carousel-templates';
import { CanvasToolbar } from './canvas-toolbar';
import { SlideThumbnails } from './slide-thumbnails';
import { PropertyPanel } from './property-panel';
import { TemplateSelectorModal } from './template-selector-modal';
import { ExportDialog } from './export-dialog';
import { AiContentGenerator } from './ai-content-generator';
import { SaveTemplateDialog } from './save-template-dialog';
import {
  exportCarouselToPDF,
  exportSlideToDataUrl,
  downloadBlob,
  generateFilename,
} from '@/lib/canvas-pdf-export';
import { cn } from '@/lib/utils';
import type { CanvasTemplate, CanvasSlide, ExportOptions } from '@/types/canvas-editor';
import type { CanvasStageRef } from './canvas-stage';

// Dynamic import for Konva (client-side only)
const CanvasStage = dynamic(
  () => import('./canvas-stage').then((mod) => mod.CanvasStage),
  { ssr: false, loading: () => <CanvasLoading /> }
);

/**
 * Loading placeholder for canvas
 */
function CanvasLoading() {
  return (
    <div className="flex h-full w-full items-center justify-center bg-muted/30">
      <div className="flex flex-col items-center gap-3">
        <div className="h-8 w-8 animate-spin rounded-full border-2 border-primary border-t-transparent" />
        <p className="text-sm text-muted-foreground">Loading editor...</p>
      </div>
    </div>
  );
}

/**
 * Props for the CanvasEditor component
 */
interface CanvasEditorProps {
  initialTemplate?: CanvasTemplate;
  onSave?: (slides: CanvasTemplate['defaultSlides']) => void;
  className?: string;
}

/**
 * Canvas Editor Component
 * Full carousel editing experience with templates, properties, and export
 */
export function CanvasEditor({
  initialTemplate,
  onSave,
  className,
}: CanvasEditorProps) {
  const stageRef = useRef<CanvasStageRef>(null);
  const [showTemplateModal, setShowTemplateModal] = useState(!initialTemplate);
  const [showExportDialog, setShowExportDialog] = useState(false);
  const [showAiGenerator, setShowAiGenerator] = useState(false);
  const [showSaveTemplateDialog, setShowSaveTemplateDialog] = useState(false);
  const [exportProgress, setExportProgress] = useState(0);

  // Carousel template persistence
  const { saveTemplate, isSaving: isSavingTemplate } = useCarouselTemplates();

  // Canvas editor state
  const {
    slides,
    currentSlideIndex,
    currentSlide,
    selectedElementId,
    selectedElement,
    template,
    zoom,
    showGrid,
    isExporting,
    setSlides,
    setCurrentSlide,
    addSlide,
    deleteSlide,
    duplicateSlide,
    reorderSlides,
    updateSlideBackground,
    selectElement,
    updateElement,
    addElement,
    addImageElement,
    deleteElement,
    applyTemplate,
    setZoom,
    toggleGrid,
    setExporting,
    undo,
    redo,
    canUndo,
    canRedo,
    resetEditor,
  } = useCanvasEditor();

  // Apply initial template
  useEffect(() => {
    if (initialTemplate) {
      applyTemplate(initialTemplate);
    }
  }, [initialTemplate, applyTemplate]);

  /**
   * Handle keyboard shortcuts
   */
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Don't handle shortcuts when editing text
      const target = e.target as HTMLElement;
      if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
        return;
      }

      // Undo: Ctrl+Z
      if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        undo();
      }

      // Redo: Ctrl+Shift+Z or Ctrl+Y
      if ((e.ctrlKey && e.shiftKey && e.key === 'z') || (e.ctrlKey && e.key === 'y')) {
        e.preventDefault();
        redo();
      }

      // Delete selected element
      if ((e.key === 'Delete' || e.key === 'Backspace') && selectedElementId) {
        e.preventDefault();
        deleteElement();
      }

      // Deselect: Escape
      if (e.key === 'Escape') {
        selectElement(null);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [undo, redo, deleteElement, selectElement, selectedElementId]);

  /**
   * Handle template selection
   */
  const handleSelectTemplate = useCallback(
    (selectedTemplate: CanvasTemplate) => {
      applyTemplate(selectedTemplate);
    },
    [applyTemplate]
  );

  /**
   * Handle AI-generated slides
   * Replaces current slides with AI-generated content
   * @param generatedSlides - Slides generated by the AI carousel generator
   */
  const handleAiGenerated = useCallback(
    (generatedSlides: CanvasSlide[]) => {
      setSlides(generatedSlides);
    },
    [setSlides]
  );

  /**
   * Handle element update from property panel
   */
  const handleElementUpdate = useCallback(
    (updates: Parameters<typeof updateElement>[1]) => {
      if (selectedElementId) {
        updateElement(selectedElementId, updates);
      }
    },
    [selectedElementId, updateElement]
  );

  /**
   * Handle slide background change
   */
  const handleSlideBackgroundChange = useCallback(
    (color: string) => {
      updateSlideBackground(currentSlideIndex, color);
    },
    [currentSlideIndex, updateSlideBackground]
  );

  /**
   * Handle export
   */
  const handleExport = useCallback(
    async (options: ExportOptions) => {
      setExporting(true);
      setExportProgress(0);

      try {
        const stage = stageRef.current?.getStage();
        if (!stage) {
          throw new Error('Canvas not ready');
        }

        if (options.format === 'pdf') {
          // Collect data URLs for all slides
          const dataUrls: string[] = [];
          const originalSlideIndex = currentSlideIndex;

          for (let i = 0; i < slides.length; i++) {
            // Switch to each slide and capture
            setCurrentSlide(i);
            // Wait a frame for the canvas to update
            await new Promise((resolve) => requestAnimationFrame(resolve));
            await new Promise((resolve) => setTimeout(resolve, 100));

            const dataUrl = exportSlideToDataUrl(stage, options.pixelRatio);
            dataUrls.push(dataUrl);
            setExportProgress((i + 1) / slides.length);
          }

          // Restore original slide
          setCurrentSlide(originalSlideIndex);

          // Generate PDF
          const pdfBlob = await exportCarouselToPDF(dataUrls, options);
          const filename =
            options.fileName || generateFilename('carousel', 'pdf');
          downloadBlob(pdfBlob, filename);
        } else {
          // PNG export for current slide only
          const dataUrl = exportSlideToDataUrl(stage, options.pixelRatio);
          const response = await fetch(dataUrl);
          const blob = await response.blob();
          const filename =
            options.fileName ||
            generateFilename(`slide-${currentSlideIndex + 1}`, 'png');
          downloadBlob(blob, filename);
        }

        setShowExportDialog(false);
      } catch (error) {
        console.error('Export failed:', error);
        // TODO: Show error toast
      } finally {
        setExporting(false);
        setExportProgress(0);
      }
    },
    [slides, currentSlideIndex, setCurrentSlide, setExporting]
  );

  /**
   * Handle zoom controls
   */
  const handleZoomIn = useCallback(() => {
    setZoom(Math.min(2, zoom + 0.1));
  }, [zoom, setZoom]);

  const handleZoomOut = useCallback(() => {
    setZoom(Math.max(0.25, zoom - 0.1));
  }, [zoom, setZoom]);

  const handleZoomReset = useCallback(() => {
    setZoom(1);
  }, [setZoom]);

  /**
   * Handle reset with confirmation
   */
  const handleReset = useCallback(() => {
    if (window.confirm('Are you sure you want to reset? All changes will be lost.')) {
      resetEditor();
      setShowTemplateModal(true);
    }
  }, [resetEditor]);

  /**
   * Handle saving the current carousel as a reusable template
   * Persists slides, brand colors, and fonts via the API
   * @param data - Form data containing name, description, and category
   */
  const handleSaveTemplate = useCallback(
    async (data: { name: string; description?: string; category: string }) => {
      const fonts = template?.fonts || [];
      const brandColors = template?.brandColors || [];

      const result = await saveTemplate({
        name: data.name,
        description: data.description,
        category: data.category,
        slides,
        brandColors,
        fonts,
      });

      if (result) {
        toast.success('Template saved successfully');
        setShowSaveTemplateDialog(false);
      } else {
        toast.error('Failed to save template');
      }
    },
    [slides, template, saveTemplate]
  );

  // Get template colors for color picker
  const templateColors = template?.brandColors || [];

  return (
    <div className={cn('flex h-full flex-col', className)}>
      {/* Toolbar */}
      <CanvasToolbar
        zoom={zoom}
        showGrid={showGrid}
        canUndo={canUndo}
        canRedo={canRedo}
        onUndo={undo}
        onRedo={redo}
        onZoomIn={handleZoomIn}
        onZoomOut={handleZoomOut}
        onZoomReset={handleZoomReset}
        onToggleGrid={toggleGrid}
        onOpenTemplates={() => setShowTemplateModal(true)}
        onOpenAiGenerator={() => setShowAiGenerator(true)}
        onSaveTemplate={() => setShowSaveTemplateDialog(true)}
        onExport={() => setShowExportDialog(true)}
        onReset={handleReset}
      />

      {/* Main content area */}
      <div className="flex flex-1 overflow-hidden">
        {/* Left sidebar: Slide thumbnails */}
        <SlideThumbnails
          slides={slides}
          currentSlideIndex={currentSlideIndex}
          onSlideSelect={setCurrentSlide}
          onAddSlide={addSlide}
          onDeleteSlide={deleteSlide}
          onDuplicateSlide={duplicateSlide}
          onReorderSlides={reorderSlides}
        />

        {/* Center: Canvas */}
        <div className="flex-1 overflow-hidden">
          {currentSlide && (
            <CanvasStage
              ref={stageRef}
              slide={currentSlide}
              selectedElementId={selectedElementId}
              onElementSelect={selectElement}
              onElementUpdate={updateElement}
              zoom={zoom}
              showGrid={showGrid}
              onImageDrop={addImageElement}
            />
          )}
        </div>

        {/* Right sidebar: Property panel */}
        <PropertyPanel
          selectedElement={selectedElement}
          currentSlide={currentSlide}
          templateColors={templateColors}
          onElementUpdate={handleElementUpdate}
          onSlideBackgroundChange={handleSlideBackgroundChange}
          onAddElement={addElement}
          onAddImageElement={addImageElement}
          onDeleteElement={deleteElement}
        />
      </div>

      {/* Template selector modal */}
      <TemplateSelectorModal
        open={showTemplateModal}
        onOpenChange={setShowTemplateModal}
        onSelectTemplate={handleSelectTemplate}
      />

      {/* Export dialog */}
      <ExportDialog
        open={showExportDialog}
        onOpenChange={setShowExportDialog}
        onExport={handleExport}
        isExporting={isExporting}
        slideCount={slides.length}
        exportProgress={exportProgress}
      />

      {/* AI Content Generator dialog */}
      <AiContentGenerator
        open={showAiGenerator}
        onOpenChange={setShowAiGenerator}
        onGenerated={handleAiGenerated}
        currentTemplate={template}
        currentSlides={slides}
      />

      {/* Save Template dialog */}
      <SaveTemplateDialog
        open={showSaveTemplateDialog}
        onOpenChange={setShowSaveTemplateDialog}
        onSave={handleSaveTemplate}
        isSaving={isSavingTemplate}
        brandColors={templateColors}
      />
    </div>
  );
}
